{
  "id": "rocket-punch",
  "name": "ç«ç®­é‡æ‹³",
  "description": "é€‰æ‹©ä¸€ä¸ªåŒè¡Œæˆ–åŒåˆ—çš„æ ¼å­ï¼Œå‘è¯¥æ–¹å‘å†²åˆº3å¹¶å¯¹è·¯å¾„ä¸Šçš„æ•Œäººé€ æˆä¼¤å®³ï¼Œåœåœ¨ç¬¬ä¸€ä¸ªæ•Œäººæˆ–éšœç¢ç‰©é¢å‰",
  "icon": "ğŸ‘Š",
  "kind": "active",
  "type": "normal",
  "cooldownTurns": 2,
  "maxCharges": 0,
  "powerMultiplier": 2.0,
  "actionPointCost": 2,
  "code": "function executeSkill(context) { const targetPosition = selectTarget({ type: 'grid', range: 5, filter: 'all' }); if (!targetPosition || targetPosition.needsTargetSelection) { return targetPosition; } if (sourcePiece.x !== targetPosition.x && sourcePiece.y !== targetPosition.y) { return { message: 'ç›®æ ‡æ ¼å­å¿…é¡»ä¸å½“å‰ä½ç½®åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—', success: false }; } let direction = ''; if (sourcePiece.x === targetPosition.x) { direction = targetPosition.y < sourcePiece.y ? 'up' : 'down'; } else { direction = targetPosition.x < sourcePiece.x ? 'left' : 'right'; } let hitEnemies = []; const damageValue = Math.round(sourcePiece.attack * context.skill.powerMultiplier); for (let i = 1; i <= 3; i++) { let checkX = sourcePiece.x; let checkY = sourcePiece.y; switch (direction) { case 'up': checkY -= i; break; case 'down': checkY += i; break; case 'left': checkX -= i; break; case 'right': checkX += i; break; } const enemyAtCheck = battle.pieces.find(p => p.x === checkX && p.y === checkY && p.currentHp > 0 && p.ownerPlayerId !== sourcePiece.ownerPlayerId); if (enemyAtCheck) { hitEnemies.push(enemyAtCheck); } } let finalX = sourcePiece.x; let finalY = sourcePiece.y; for (let step = 1; step <= 3; step++) { let nextX = finalX; let nextY = finalY; switch (direction) { case 'up': nextY--; break; case 'down': nextY++; break; case 'left': nextX--; break; case 'right': nextX++; break; } const hasEnemy = battle.pieces.some(p => p.x === nextX && p.y === nextY && p.currentHp > 0); const isOutOfBounds = nextX < 0 || nextX >= battle.map.width || nextY < 0 || nextY >= battle.map.height; if (hasEnemy || isOutOfBounds) { break; } finalX = nextX; finalY = nextY; } sourcePiece.x = finalX; sourcePiece.y = finalY; hitEnemies.forEach(enemy => { dealDamage(sourcePiece, enemy, damageValue, 'physical', battle, context.skill.id); }); return { message: sourcePiece.name + ' ä½¿ç”¨äº†ç«ç®­é‡æ‹³ï¼Œå¯¹è·¯å¾„ä¸Šçš„æ•Œäººé€ æˆäº†ä¼¤å®³', success: true }; }",
  "previewCode": "function calculatePreview(piece, skillDef) { const damageValue = Math.round(piece.attack * skillDef.powerMultiplier); return { description: 'é€‰æ‹©åŒè¡Œæˆ–åŒåˆ—çš„æ ¼å­å†²åˆºï¼Œå¯¹è·¯å¾„ä¸Šçš„æ•Œäººé€ æˆ' + damageValue + 'ç‚¹ä¼¤å®³(ç›¸å½“äºæ”»å‡»åŠ›200%)', expectedValues: { damage: damageValue, range: 5 } }; }",
  "range": "single"
}
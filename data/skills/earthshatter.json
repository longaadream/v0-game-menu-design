{"id":"earthshatter","name":"æ¯å¤©ç­åœ°","description":"é€‰æ‹©ä¸€ä¸ªæ— é®æŒ¡å’Œæ£‹å­çš„æ ¼å­ï¼Œä»å¤©è€Œé™é™è½åˆ°è¯¥æ ¼å­å¹¶å¯¹ä»¥è¯¥æ ¼å­ä¸ºä¸­å¿ƒçš„3*3åŒºåŸŸçš„æ•Œäººé€ æˆ100%æ”»å‡»åŠ›çš„ç‰©ç†ä¼¤å®³","icon":"ğŸŒ‹","kind":"active","type":"super","cooldownTurns":1,"maxCharges":3,"chargeCost":2,"powerMultiplier":1.0,"actionPointCost":2,"code":"function executeSkill(context) { const targetPos = selectTarget({ type: 'grid', range: 10, filter: 'all' }); if (!targetPos || targetPos.needsTargetSelection) { return targetPos; } const pieceAtPos = context.battle.pieces.find(p => p.x === targetPos.x && p.y === targetPos.y && p.currentHp > 0); if (pieceAtPos) { return { message: 'è¯¥ä½ç½®å·²æœ‰æ£‹å­', success: false }; } sourcePiece.x = targetPos.x; sourcePiece.y = targetPos.y; const damageValue = sourcePiece.attack * context.skill.powerMultiplier; const affectedEnemies = []; let totalDamage = 0; for (let dx = -1; dx <= 1; dx++) { for (let dy = -1; dy <= 1; dy++) { const checkPos = { x: targetPos.x + dx, y: targetPos.y + dy }; const enemyAtPos = context.battle.pieces.find(p => p.x === checkPos.x && p.y === checkPos.y && p.currentHp > 0 && p.ownerPlayerId !== sourcePiece.ownerPlayerId); if (enemyAtPos) { affectedEnemies.push(enemyAtPos.name); const damageResult = dealDamage(sourcePiece, enemyAtPos, damageValue, 'physical', context.battle, context.skill.id); totalDamage += damageResult.damage; } } } if (affectedEnemies.length > 0) { return { message: sourcePiece.name + ' ä»å¤©è€Œé™ï¼Œå¯¹ ' + affectedEnemies.join(', ') + ' é€ æˆ ' + totalDamage + ' ç‚¹ä¼¤å®³', success: true }; } return { message: sourcePiece.name + ' ä»å¤©è€Œé™', success: true }; }","previewCode":"function calculatePreview(piece, skillDef) { const damageValue = Math.round(piece.attack * skillDef.powerMultiplier); return { description: 'é€‰æ‹©ä¸€ä¸ªå®‰å…¨ä½ç½®é™è½ï¼Œå¯¹3*3åŒºåŸŸå†…çš„æ•Œäººé€ æˆ' + damageValue + 'ç‚¹ä¼¤å®³ï¼ˆç›¸å½“äºæ”»å‡»åŠ›100%ï¼‰', expectedValues: { damage: damageValue, area: '3*3' } }; }"}
{
  "id": "death-blossom",
  "name": "æ­»äº¡ç»½æ”¾",
  "description": "å¯¹ä¸‰æ ¼å†…æ‰€æœ‰çš„æ•Œäººé€ æˆ200%æ”»å‡»åŠ›çš„ä¼¤å®³",
  "icon": "ğŸŒ¸",
  "kind": "active",
  "type": "normal",
  "form": "projectile",
  "cooldownTurns": 3,
  "maxCharges": 0,
  "powerMultiplier": 2.0,
  "actionPointCost": 3,
  "range": "area",
  "areaSize": 3,
  "requiresTarget": false,
  "code": "function executeSkill(context) { const sourcePiece = context.piece; const damageValue = Math.round(sourcePiece.attack * context.skill.powerMultiplier); const enemiesInRange = getAllEnemiesInRange(3); if (enemiesInRange.length === 0) { return { message: 'èŒƒå›´å†…æ²¡æœ‰æ•Œäºº', success: false }; } let totalDamage = 0; let killedCount = 0; let hitMessages = []; for (const enemy of enemiesInRange) { const dx = enemy.x - sourcePiece.x; const dy = enemy.y - sourcePiece.y; const stepX = dx === 0 ? 0 : dx > 0 ? 1 : -1; const stepY = dy === 0 ? 0 : dy > 0 ? 1 : -1; let currentX = sourcePiece.x + stepX; let currentY = sourcePiece.y + stepY; let blocked = false; while (currentX !== enemy.x || currentY !== enemy.y) { const tile = battle.map.tiles.find(t => t.x === currentX && t.y === currentY); if (!tile || tile.props.bullet === false) { blocked = true; break; } const pieceInPath = battle.pieces.find(p => p.x === currentX && p.y === currentY && p.currentHp > 0 && p.instanceId !== enemy.instanceId); if (pieceInPath) { blocked = true; break; } currentX += stepX; currentY += stepY; } if (blocked) { continue; } const enemyPiece = battle.pieces.find(p => p.instanceId === enemy.instanceId); if (enemyPiece) { const damageResult = dealDamage(sourcePiece, enemyPiece, damageValue, 'physical', battle, context.skill.id); totalDamage += damageResult.damage; if (damageResult.isKilled) { killedCount++; } hitMessages.push(enemyPiece.name + 'å—åˆ°' + damageResult.damage + 'ç‚¹ä¼¤å®³'); } } if (hitMessages.length === 0) { return { message: 'æ‰€æœ‰æ•Œäººéƒ½è¢«éšœç¢ç‰©æˆ–æ£‹å­é®æŒ¡', success: false }; } let message = sourcePiece.name + 'é‡Šæ”¾æ­»äº¡ç»½æ”¾ï¼Œ'; message += hitMessages.join('ï¼Œ'); if (killedCount > 0) { message += 'ï¼Œå‡»æ€äº†' + killedCount + 'ä¸ªæ•Œäºº'; } return { message: message, success: true }; }",
  "previewCode": "function calculatePreview(piece, skillDef) { const damageValue = Math.round(piece.attack * skillDef.powerMultiplier); return { description: 'å¯¹3æ ¼å†…æ‰€æœ‰æœªè¢«é®æŒ¡çš„æ•Œäººé€ æˆ' + damageValue + 'ç‚¹ä¼¤å®³ï¼ˆç›¸å½“äºæ”»å‡»åŠ›200%ï¼‰', expectedValues: { damage: damageValue } }; }"
}

{
  "id": "shadow-step",
  "name": "æš—å½±æ­¥",
  "description": "é€‰æ‹©åœ°å›¾ä¸Šä¸€ä¸ªæœªè¢«é®æŒ¡çš„æ ¼å­ï¼Œåœ¨ä¸‹ä¸ªå›åˆå¼€å§‹çš„æ—¶å€™ä¼ é€",
  "icon": "ğŸ‘¤",
  "kind": "active",
  "type": "normal",
  "cooldownTurns": 2,
  "maxCharges": 0,
  "powerMultiplier": 1,
  "actionPointCost": 3,
  "range": "single",
  "requiresTarget": true,
  "code": "function executeSkill(context) { console.log('[ShadowStep] Executing shadow-step skill'); const sourcePiece = context.piece; console.log('[ShadowStep] sourcePiece:', sourcePiece ? sourcePiece.instanceId : 'null'); const targetPosition = selectTarget({ type: 'grid', range: 10, filter: 'all' }); console.log('[ShadowStep] targetPosition:', targetPosition); if (!targetPosition || targetPosition.needsTargetSelection) { return targetPosition; } const tile = battle.map.tiles.find(t => t.x === targetPosition.x && t.y === targetPosition.y); console.log('[ShadowStep] tile:', tile ? 'found' : 'not found'); if (!tile || !tile.props.walkable) { return { message: 'ç›®æ ‡ä½ç½®ä¸å¯è¡Œèµ°', success: false }; } const pieceAtPos = battle.pieces.find(p => p.x === targetPosition.x && p.y === targetPosition.y && p.currentHp > 0); if (pieceAtPos) { return { message: 'ç›®æ ‡ä½ç½®å·²è¢«å ç”¨', success: false }; } if (!sourcePiece.statusTags) { sourcePiece.statusTags = []; } const existingShadowStep = sourcePiece.statusTags.find(tag => tag.type === 'shadow-step'); if (existingShadowStep) { console.log('[ShadowStep] Updating existing shadow-step status'); const oldX = existingShadowStep.value; const oldY = existingShadowStep.intensity; const oldTile = battle.map.tiles.find(t => t.x === oldX && t.y === oldY); if (oldTile) { oldTile.props.walkable = true; oldTile.props.shadowStepTarget = false; } existingShadowStep.value = targetPosition.x; existingShadowStep.intensity = targetPosition.y; existingShadowStep.remainingDuration = 2; } else { console.log('[ShadowStep] Creating new shadow-step status'); sourcePiece.statusTags.push({ id: 'shadow-step-' + Date.now(), type: 'shadow-step', name: 'æš—å½±æ­¥', remainingDuration: 2, value: targetPosition.x, intensity: targetPosition.y, relatedRules: ['rule-shadow-step'] }); } tile.props.walkable = false; tile.props.shadowStepTarget = true; if (!sourcePiece.rules) { sourcePiece.rules = []; } const hasRule = sourcePiece.rules.some(r => r.id === 'rule-shadow-step'); console.log('[ShadowStep] hasRule:', hasRule); if (!hasRule) { console.log('[ShadowStep] Adding rule-shadow-step'); const result = addRuleById(sourcePiece.instanceId, 'rule-shadow-step'); console.log('[ShadowStep] addRuleById result:', result); } return { message: sourcePiece.name + 'æ ‡è®°äº†æš—å½±æ­¥ä½ç½®ï¼Œå°†åœ¨ä¸‹å›åˆå¼€å§‹æ—¶ä¼ é€åˆ°(' + targetPosition.x + ',' + targetPosition.y + ')', success: true }; }",
  "previewCode": "function calculatePreview(piece, skillDef) { return { description: 'é€‰æ‹©åœ°å›¾ä¸Šä¸€ä¸ªæœªè¢«é®æŒ¡çš„æ ¼å­ï¼Œåœ¨ä¸‹ä¸ªå›åˆå¼€å§‹æ—¶è‡ªåŠ¨ä¼ é€', expectedValues: {} }; }"
}

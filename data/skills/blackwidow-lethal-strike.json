{
  "id": "blackwidow-lethal-strike",
  "name": "è‡´å‘½æ‰“å‡»",
  "description": "é€‰æ‹©ä¸€ä¸ªåŒè¡Œæˆ–åŒåˆ—çš„æ ¼å­ä½œä¸ºæ–¹å‘ï¼Œå‘è¯¥æ–¹å‘å°„å‡ºä¸€å‘å­å¼¹ï¼Œå¯¹è·¯å¾„ä¸Šç¬¬ä¸€ä¸ªæ•Œäººé€ æˆ(1+é—´éš”æ ¼æ•°*0.1)å€æ”»å‡»åŠ›çš„ä¼¤å®³ã€‚è¢«å­å¼¹:falseçš„æ ¼å­æ‹¦æˆªã€‚",
  "icon": "ğŸ¯",
  "kind": "active",
  "type": "normal",
  "cooldownTurns": 2,
  "maxCharges": 0,
  "powerMultiplier": 1,
  "actionPointCost": 2,
  "code": "function executeSkill(context) { var caster = context.piece; var targetPos = selectTarget({ type: 'grid', range: 99, filter: 'all' }); if (!targetPos || targetPos.needsTargetSelection) return targetPos; var dx = targetPos.x - caster.x; var dy = targetPos.y - caster.y; if (dx !== 0 && dy !== 0) { return { success: false, message: 'å¿…é¡»é€‰æ‹©ä¸è‡ªå·±åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—çš„æ ¼å­' }; } var dirX = dx === 0 ? 0 : (dx > 0 ? 1 : -1); var dirY = dy === 0 ? 0 : (dy > 0 ? 1 : -1); var firstEnemy = null; var hitDistance = 0; for (var i = 1; i <= 99; i++) { var checkX = caster.x + dirX * i; var checkY = caster.y + dirY * i; var tile = context.battle.map.tiles.find(function(t) { return t.x === checkX && t.y === checkY; }); if (!tile) { break; } if (tile.props && tile.props.bulletPassable === false) { break; } var enemy = context.battle.pieces.find(function(p) { return p.x === checkX && p.y === checkY && p.currentHp > 0 && p.ownerPlayerId !== caster.ownerPlayerId; }); if (enemy) { firstEnemy = enemy; hitDistance = i; break; } } if (!firstEnemy) { return { success: false, message: 'è·¯å¾„ä¸Šæ²¡æœ‰æ•Œäºº' }; } var damageMultiplier = 1 + (hitDistance * 0.1); var damage = Math.round(caster.attack * damageMultiplier); var result = dealDamage(caster, firstEnemy, damage, 'physical', context.battle, context.skill.id); return { success: true, message: caster.name + 'å¯¹' + firstEnemy.name + 'é€ æˆ' + result.damage + 'ç‚¹ä¼¤å®³ï¼ˆè·ç¦»' + hitDistance + 'æ ¼ï¼‰' }; }",
  "previewCode": "function calculatePreview(piece, skillDef) { return { description: 'å‘é€‰æ‹©æ–¹å‘å‘å°„å­å¼¹ï¼Œå¯¹ç¬¬ä¸€ä¸ªæ•Œäººé€ æˆ(1+è·ç¦»*0.1)å€ä¼¤å®³', expectedValues: { damage: Math.round(piece.attack * 1.1) } }; }"
}
